# PRIMM Recursion

PRIMM is an acronym that stands for predict, run, investigate, modify, make.
PRIMM is a really good model to adopt whenever you encounter a new piece of code
or a new library you want to understand. In addition, it's my belief that it
will become a very useful model for using code generated by ChatBots to solve
problems that are of interest to you.

In this worksheet, we will use PRIMM to help us understand recursion: a subject
that will come up a lot in this class and future CS classes.

## Shape One

First, we’re going to experiment with the shape produced by the `shape_one()`
function.

### Predict

1. How is `shape_one()` recursive?
   ```
   
   
   ```
2. Draw your best guess of what will happen for a call to `shape_one()` that
   results in no recursive calls (aka: the base case):
   ```
   
   
   ```
3. Draw your best guess of what will happen for a call to `shape_one()` that
   results in one level of recursive calls:
   ```
   
   
   ```
4. Based on your sketches, what do you think `shape_one()` is creating?
   ```

   ```

### Run

1. Draw the result that comes from running `shape_one()`:
   ```


   ```

### Investigate

1. What is the role of each parameter in the shape_one() function? How do they
   influence the shape that is output?
   ```


   ```
2. How does the depth of recursion affect the shape? What happens as you
   increase or decrease the depth?
   ```


   ```
3. How is the size of each branch determined relative to its parent branch?
   What would happen if you change the scaling factor?
   ```


   ```

### Modify

1. Alter the code so there only right angle turns. Draw the result:
   ```


   ```

2. Alter the code so that there is a third recursive call. Make sure that the
   result is symmetrical. Draw the result:
   ```


   ```
3. Alter the code so that the base case results in a small circle. Draw the
   result:
   ```


   ```

## Shape Two

First, we’re going to experiment with the shape produced by the `shape_two()`
function. Make sure that `shape_one()` is commented out and `shape_two()` is
uncommented.

### Predict

1. How is `shape_two()` recursive?
   ```


   ```
2. Draw your best guess of what will happen for a call to `shape_two()` that
   results in no recursive calls (the base case):
   ```


   ```
3. Draw your best guess of what will happen for a call to `shape_two()` that
   results in one level of recursive calls:
   ```

 
   ```
4. Based on your sketches, what do you think `shape_two()` is creating?
   ```

 
   ```

### Run

1. Draw the result that comes from running `shape_two()`:
   ```


   ```

### Investigate

1. Analyze how the function divides each line segment. What is the rule for
   division, and how does it create the resulting shape?
   ```


   ```
2. How does the base case determine the most detailed level of the shape?
   ```


   ```

### Modify

1.	Add code so that the resulting shape is a closed circle/figure. Draw the
    result:
    ```
    
    
    
    ```
2. Alter the code so there only right angle turns. Draw the result:
    ```
    
    
    
    ```

## Shape Three

Now it’s your turn to `make`. In the space below, draw a self-similar pattern.
Then, create a function called `shape_three()` to try and recreate it via a
turtle.
